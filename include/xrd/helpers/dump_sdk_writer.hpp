#pragma once
// Xrd-eXternalrEsolve - SDK 导出：分包文件写入器
// 负责写入 _classes.hpp / _structs.hpp / _functions.cpp / _parameters.hpp
// 以及追加断言宏到 Assertions.inl
// 包含跨包 #include 依赖追踪

#include "dump_sdk_struct.hpp"
#include "dump_enum.hpp"
#include "dump_deps.hpp"
#include "gen/gen_predefined_func_impl.hpp"
#include <fstream>
#include <string>
#include <format>
#include <vector>
#include <map>
#include <algorithm>
#include <unordered_map>
#include <Windows.h>

namespace xrd
{
namespace detail
{

// UTF-8 字符串转 wstring（正确处理中文等多字节字符）
inline std::wstring Utf8ToWide(const std::string& utf8)
{
    if (utf8.empty())
    {
        return L"";
    }
    int needed = MultiByteToWideChar(
        CP_UTF8, 0, utf8.data(), (int)utf8.size(), nullptr, 0);
    if (needed <= 0)
    {
        return std::wstring(utf8.begin(), utf8.end());
    }
    std::wstring wide(needed, L'\0');
    MultiByteToWideChar(
        CP_UTF8, 0, utf8.data(), (int)utf8.size(),
        wide.data(), needed);
    return wide;
}

// ─── 跨包依赖追踪 ───
// PackageDeps 和依赖收集函数已移至 dump_deps.hpp

// 写入文件头（所有 SDK 文件共用）
// 对标 Rei-Dumper：UTF-8 BOM + #pragma once
inline void WriteFileHeader(
    std::ofstream& f,
    const std::string& pkgName)
{
    // UTF-8 BOM（对标 Rei-Dumper）
    f << "\xEF\xBB\xBF";
    f << "#pragma once\n\n";
    f << "/*\n";
    f << "* SDK generated by Xrd-eXternalrEsolve\n";
    f << "* Based on Dumper-7\n";
    f << "*\n";
    f << "* https://github.com/Encryqed/Dumper-7\n";
    f << "*/\n\n";
    f << "// Package: " << pkgName << "\n\n";
    f << "#include \"Basic.hpp\"\n";
}

// 写入跨包 #include（对标 Rei-Dumper）
// deps 的 key 是包的 GObjects 索引
// 按包索引升序排列，保证输出顺序确定性
inline void WriteDepsIncludes(
    std::ofstream& f,
    const PackageDeps& deps,
    const std::unordered_map<i32, std::string>& pkgIdxToSanitized,
    const std::unordered_set<i32>* pkgsWithStructs = nullptr)
{
    if (deps.deps.empty())
    {
        f << "\n";
        return;
    }

    f << "\n";

    // 按包索引升序排列，保证输出顺序与 Rei-Dumper 一致
    std::vector<std::pair<i32, PackageDeps::DepInfo>> sorted(
        deps.deps.begin(), deps.deps.end());
    std::sort(sorted.begin(), sorted.end(),
        [](const auto& a, const auto& b)
        {
            return a.first < b.first;
        });

    for (const auto& [depPkgIdx, info] : sorted)
    {
        auto it = pkgIdxToSanitized.find(depPkgIdx);
        if (it == pkgIdxToSanitized.end())
        {
            continue;
        }
        const std::string& depSanitized = it->second;
        if (info.needStructs)
        {
            // 只有目标包确实有 structs 文件时才输出 include
            if (!pkgsWithStructs
                || pkgsWithStructs->count(depPkgIdx))
            {
                f << "#include \"" << depSanitized
                  << "_structs.hpp\"\n";
            }
        }
        if (info.needClasses)
        {
            f << "#include \"" << depSanitized
              << "_classes.hpp\"\n";
        }
    }
    f << "\n";
}

// 写入 _structs.hpp — 枚举 + 结构体定义
inline void WriteStructsFile(
    const std::wstring& sdkDir,
    const std::string& sanitizedName,
    const std::string& rawPkgName,
    const std::vector<const StructEntry*>& structs,
    const std::vector<EnumInfo>& enums,
    const PackageDeps& deps,
    const std::unordered_map<i32, std::string>& pkgIdxMap,
    const std::unordered_set<i32>* pkgsWithStructs = nullptr)
{
    if (structs.empty() && enums.empty())
    {
        return;
    }

    std::wstring wName = Utf8ToWide(sanitizedName);
    std::wstring path = sdkDir + L"/" + wName + L"_structs.hpp";
    std::ofstream f(path);
    if (!f.is_open())
    {
        return;
    }

    WriteFileHeader(f, rawPkgName);
    WriteDepsIncludes(f, deps, pkgIdxMap, pkgsWithStructs);
    f << "\nnamespace SDK\n{\n\n";

    for (auto& ei : enums)
    {
        f << GenerateEnumCode(ei);
    }

    for (auto* entry : structs)
    {
        f << GenerateStructCode(*entry);
    }

    f << "}\n\n";
    f.close();
}

// 写入 _classes.hpp — 类定义
inline void WriteClassesFile(
    const std::wstring& sdkDir,
    const std::string& sanitizedName,
    const std::string& rawPkgName,
    const std::vector<const StructEntry*>& classes,
    const PackageDeps& deps,
    const std::unordered_map<i32, std::string>& pkgIdxMap,
    bool hasStructsFile = false,
    bool classesNeedOwnStructs = false,
    const std::unordered_set<i32>* pkgsWithStructs = nullptr)
{
    if (classes.empty())
    {
        return;
    }

    std::wstring wName = Utf8ToWide(sanitizedName);
    std::wstring path = sdkDir + L"/" + wName + L"_classes.hpp";
    std::ofstream f(path);
    if (!f.is_open())
    {
        return;
    }

    WriteFileHeader(f, rawPkgName);

    // 对标 Rei-Dumper：classes 文件的跨包依赖 include
    bool hasDeps = !deps.deps.empty() || classesNeedOwnStructs;
    if (!hasDeps)
    {
        f << "\n";
    }
    else
    {
        f << "\n";

        // 按包索引升序排列，保证输出顺序确定性
        std::vector<std::pair<i32, PackageDeps::DepInfo>> sorted(
            deps.deps.begin(), deps.deps.end());
        std::sort(sorted.begin(), sorted.end(),
            [](const auto& a, const auto& b)
            {
                return a.first < b.first;
            });

        for (const auto& [depPkgIdx, info] : sorted)
        {
            auto it = pkgIdxMap.find(depPkgIdx);
            if (it == pkgIdxMap.end())
            {
                continue;
            }
            const std::string& depSanitized = it->second;
            if (info.needStructs)
            {
                // 只有目标包确实有 structs 文件时才输出 include
                if (!pkgsWithStructs
                    || pkgsWithStructs->count(depPkgIdx))
                {
                    f << "#include \"" << depSanitized
                      << "_structs.hpp\"\n";
                }
            }
            if (info.needClasses)
            {
                f << "#include \"" << depSanitized
                  << "_classes.hpp\"\n";
            }
        }

        // 自包 structs include（仅当类实际依赖同包结构体时）
        if (classesNeedOwnStructs && hasStructsFile)
        {
            f << "#include \"" << sanitizedName
              << "_structs.hpp\"\n";
        }

        f << "\n";
    }

    f << "\nnamespace SDK\n{\n\n";

    for (auto* entry : classes)
    {
        f << GenerateClassCode(*entry);
    }

    f << "}\n\n";
    f.close();
}

// 写入 _functions.cpp — 函数实现（ProcessEvent 调用）
// 对标 Rei-Dumper：预定义函数实现在反射函数之前
inline void WriteFunctionsFile(
    const std::wstring& sdkDir,
    const std::string& sanitizedName,
    const std::string& rawPkgName,
    const std::vector<const StructEntry*>& classes)
{
    // 检查是否有任何函数需要生成
    bool hasFuncs = false;
    // 同时检查是否有预定义函数实现
    bool hasPredefinedImpls = false;
    for (auto* entry : classes)
    {
        auto funcs = CollectFunctions(entry->addr);
        if (!funcs.empty())
        {
            hasFuncs = true;
        }
        if (!GetPredefinedFuncImpls(entry->name).empty())
        {
            hasPredefinedImpls = true;
        }
    }

    if (!hasFuncs && !hasPredefinedImpls) return;

    std::wstring wName = Utf8ToWide(sanitizedName);
    std::wstring path = sdkDir + L"/" + wName + L"_functions.cpp";
    std::ofstream f(path);
    if (!f.is_open()) return;

    // 文件头（对标 Rei-Dumper 格式，含 BOM）
    f << "\xEF\xBB\xBF";
    f << "#pragma once\n\n";
    f << "/*\n";
    f << "* SDK generated by Xrd-eXternalrEsolve\n";
    f << "* Based on Dumper-7\n";
    f << "*\n";
    f << "* https://github.com/Encryqed/Dumper-7\n";
    f << "*/\n\n";
    f << "// Package: " << rawPkgName << "\n\n";
    f << "#include \"Basic.hpp\"\n\n";
    f << "#include \"" << sanitizedName << "_classes.hpp\"\n";

    // 检查是否有参数文件（对标 Rei-Dumper：只有有实际参数的函数才算）
    bool hasParamFile = false;
    for (auto* entry : classes)
    {
        auto funcs = CollectFunctions(entry->addr);
        for (auto& func : funcs)
        {
            if (func.paramStructSize > 0 && !func.params.empty())
            {
                hasParamFile = true;
                break;
            }
        }
        if (hasParamFile) break;
    }
    if (hasParamFile)
    {
        f << "#include \"" << sanitizedName
          << "_parameters.hpp\"\n";
    }

    f << "\n\nnamespace SDK\n{\n";

    // 清理包名用于函数注释
    std::string cleanPkg = rawPkgName;

    // 对标 Rei-Dumper：反射函数在前，预定义函数实现在后
    for (auto* entry : classes)
    {
        auto funcs = CollectFunctions(entry->addr);
        if (funcs.empty()) continue;

        std::string prefixed = AddStructPrefix(
            entry->name, true,
            entry->isActorChild, entry->isInterfaceChild);

        bool isInterface = entry->isInterfaceChild;

        // 收集属性名，用于函数名冲突检测
        auto fProps = CollectProperties(entry->addr);
        std::unordered_set<std::string> fPropNames;
        for (auto& pi : fProps) fPropNames.insert(pi.name);

        for (auto& func : funcs)
        {
            FunctionInfo resolved = func;
            if (fPropNames.count(resolved.name))
            {
                resolved.name += "_";
            }
            f << "\n";
            f << GenerateFunctionImpl(
                cleanPkg, entry->name, prefixed,
                resolved, isInterface, entry->collisionNs);
        }
    }

    // 预定义函数实现在反射函数之后
    for (auto* entry : classes)
    {
        std::string predImpl = GetPredefinedFuncImpls(
            entry->name);
        if (!predImpl.empty())
        {
            f << predImpl;
        }
    }

    f << "}\n\n";
    f.close();
}

// 写入 _parameters.hpp — 函数参数结构体
inline void WriteParametersFile(
    const std::wstring& sdkDir,
    const std::string& sanitizedName,
    const std::string& rawPkgName,
    const std::vector<const StructEntry*>& classes,
    const PackageDeps& paramDeps,
    const std::unordered_map<i32, std::string>& pkgIdxMap)
{
    // 检查是否有任何函数需要参数结构体
    // 对标 Rei-Dumper：只有真正有 Parm 标记的参数才生成
    bool hasParamStructs = false;
    for (auto* entry : classes)
    {
        auto funcs = CollectFunctions(entry->addr);
        for (auto& func : funcs)
        {
            // 只有函数有实际参数（非空 params 列表）才算
            if (func.paramStructSize > 0 && !func.params.empty())
            {
                hasParamStructs = true;
                break;
            }
        }
        if (hasParamStructs) break;
    }

    if (!hasParamStructs)
    {
        return;
    }

    std::wstring wName = Utf8ToWide(sanitizedName);
    std::wstring path = sdkDir + L"/" + wName + L"_parameters.hpp";
    std::ofstream f(path);
    if (!f.is_open())
    {
        return;
    }

    WriteFileHeader(f, rawPkgName);
    WriteDepsIncludes(f, paramDeps, pkgIdxMap);
    f << "\nnamespace SDK::Params\n{\n\n";

    for (auto* entry : classes)
    {
        auto funcs = CollectFunctions(entry->addr);
        for (auto& func : funcs)
        {
            // 只有有实际参数的函数才生成参数结构体
            if (func.paramStructSize > 0 && !func.params.empty())
            {
                f << GenerateParamStruct(
                    rawPkgName, entry->name, func);
            }
        }
    }

    f << "}\n\n";
    f.close();
}

// 追加断言宏到 Assertions.inl
inline void AppendAssertions(
    std::ofstream& assertFile,
    const std::vector<const StructEntry*>& structs,
    const std::vector<const StructEntry*>& classes)
{
    if (!assertFile.is_open())
    {
        return;
    }

    for (auto* entry : structs)
    {
        std::string prefixed = AddStructPrefix(
            entry->name, entry->isClass,
            entry->isActorChild, entry->isInterfaceChild);
        // 对标 Rei-Dumper：assertion 中的 size = Align(unalignedSize, alignment)
        i32 uSize = entry->unalignedSize > 0
            ? entry->unalignedSize : entry->size;
        i32 aAlign = entry->alignment > 0
            ? entry->alignment : 1;
        i32 alignedSize = (uSize + aAlign - 1) & ~(aAlign - 1);
        assertFile << GenerateAssertionMacro(
            prefixed, prefixed, alignedSize,
            entry->alignment);
    }

    for (auto* entry : classes)
    {
        std::string prefixed = AddStructPrefix(
            entry->name, entry->isClass,
            entry->isActorChild, entry->isInterfaceChild);
        bool hasCollision = !entry->collisionNs.empty();
        std::string assertName = hasCollision
            ? (entry->collisionNs + "__" + prefixed)
            : prefixed;
        std::string typeName = hasCollision
            ? (entry->collisionNs + "::" + prefixed)
            : prefixed;

        // 对标 Rei-Dumper：interface 子类 size=0, alignment=1
        // 非 interface：sizeof = Align(size, alignment)
        i32 assertSize;
        i32 assertAlign;
        if (entry->isInterfaceChild)
        {
            assertSize = 0;
            assertAlign = 1;
        }
        else
        {
            i32 uSz = entry->unalignedSize > 0
                ? entry->unalignedSize : entry->size;
            i32 aAl = entry->alignment > 0
                ? entry->alignment : 1;
            assertSize = (uSz + aAl - 1) & ~(aAl - 1);
            assertAlign = entry->alignment;
        }

        assertFile << GenerateAssertionMacro(
            assertName, typeName, assertSize,
            assertAlign);
    }
}

} // namespace detail
} // namespace xrd
