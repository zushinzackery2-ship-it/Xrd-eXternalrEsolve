#pragma once
// Xrd-eXternalrEsolve - SDK 导出：基础设施文件生成
// 生成 Basic.hpp / Basic.cpp / SDK.hpp / 辅助文件
// 调用 gen/ 下的各模块完成 Rei-Dumper 格式对齐

#include "../core/context.hpp"
#include "gen/gen_basic_types.hpp"
#include "gen/gen_basic_core.hpp"
#include "gen/gen_basic_text.hpp"
#include "gen/gen_basic_ptrs.hpp"
#include "gen/gen_basic_enums.hpp"
#include "gen/gen_basic_ffield.hpp"
#include "gen/gen_auxiliary.hpp"
#include "gen/gen_containers.hpp"
#include <fstream>
#include <string>
#include <format>
#include <vector>
#include <filesystem>

namespace xrd
{
namespace detail
{

// 生成 Basic.hpp — 完整对标 Rei-Dumper 1262 行格式
// 调用 gen/ 下各模块按顺序写入
inline void GenerateBasicHpp(const std::wstring& sdkDir)
{
    std::wstring path = sdkDir + L"/Basic.hpp";
    std::ofstream f(path);
    if (!f.is_open())
    {
        return;
    }

    // 第一部分：文件头、Offsets、InSDKUtils、前置声明、StaticClass 宏
    gen::WriteBasicHeader(f);
    gen::WriteOffsetsNamespace(f);
    gen::WriteInSDKUtils(f);
    gen::WriteForwardDeclarations(f);
    gen::WriteStaticClassTemplates(f);
    gen::WriteStaticClassMacros(f);

    // 第二部分：FUObjectItem / TUObjectArray / FName / TSubclassOf / FText
    gen::WriteFUObjectItemAndArray(f);
    gen::WriteTUObjectArrayWrapper(f);
    gen::WriteFNameClass(f);
    gen::WriteSubclassAndText(f);

    // 第三部分：智能指针和委托类型
    gen::WritePtrAndDelegateTypes(f);

    // 第四部分：枚举定义
    gen::WriteEnumOperatorsAndEnums(f);
    gen::WriteCastAndPropertyFlags(f);

    // 第五部分：FField / FProperty 及子类
    gen::WriteFFieldAndPropertyTypes(f);

    // CyclicDependencyFixup 和命名空间闭合
    gen::WriteCyclicFixupAndClose(f);

    f.close();
}

// 生成 Basic.cpp — 对标 Rei-Dumper Basic.cpp
// 包含 GetImageBase / FindClassByName / UObject 方法实现
inline void GenerateBasicCpp(const std::wstring& sdkDir)
{
    std::wstring path = sdkDir + L"/Basic.cpp";
    std::ofstream f(path);
    if (!f.is_open())
    {
        return;
    }

    f << R"(#pragma once

/*
* SDK generated by Xrd-eXternalrEsolve
* Based on Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Basic file containing function-implementations from Basic.hpp

#include <Windows.h>
#include "Basic.hpp"

#include "CoreUObject_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "Engine_classes.hpp"

namespace SDK
{
uintptr_t InSDKUtils::GetImageBase()
{
	return reinterpret_cast<uintptr_t>(GetModuleHandle(0));
}

class UClass* BasicFilesImpleUtils::FindClassByName(const std::string& Name, bool bByFullName)
{
	return bByFullName ? UObject::FindClass(Name) : UObject::FindClassFast(Name);
}

class UClass* BasicFilesImpleUtils::FindClassByFullName(const std::string& Name)
{
	return UObject::FindClass(Name);
}

std::string BasicFilesImpleUtils::GetObjectName(class UClass* Class)
{
	return Class->GetName();
}

int32 BasicFilesImpleUtils::GetObjectIndex(class UClass* Class)
{
	return Class->Index;
}

uint64 BasicFilesImpleUtils::GetObjFNameAsUInt64(class UClass* Class)
{
	return *reinterpret_cast<uint64*>(&Class->Name);
}

class UObject* BasicFilesImpleUtils::GetObjectByIndex(int32 Index)
{
	return UObject::GObjects->GetByIndex(Index);
}

UFunction* BasicFilesImpleUtils::FindFunctionByFName(const FName* Name)
{
	for (int i = 0; i < UObject::GObjects->Num(); ++i)
	{
		UObject* Object = UObject::GObjects->GetByIndex(i);

		if (!Object)
			continue;

		if (Object->Name == *Name)
			return static_cast<UFunction*>(Object);
	}

	return nullptr;
}

FName BasicFilesImpleUtils::StringToName(const wchar_t* Name)
{
	return UKismetStringLibrary::Conv_StringToName(FString(Name));
}

const FName& GetStaticName(const wchar_t* Name, FName& StaticName)
{
	if (StaticName.IsNone())
	{
		StaticName = BasicFilesImpleUtils::StringToName(Name);
	}

	return StaticName;
}

// Predefined Function

class UObject* FWeakObjectPtr::Get() const
{
	return UObject::GObjects->GetByIndex(ObjectIndex);
}


// Predefined Function

class UObject* FWeakObjectPtr::operator->() const
{
	return UObject::GObjects->GetByIndex(ObjectIndex);
}


// Predefined Function

bool FWeakObjectPtr::operator==(const FWeakObjectPtr& Other) const
{
	return ObjectIndex == Other.ObjectIndex;
}


// Predefined Function

bool FWeakObjectPtr::operator!=(const FWeakObjectPtr& Other) const
{
	return ObjectIndex != Other.ObjectIndex;
}


// Predefined Function

bool FWeakObjectPtr::operator==(const class UObject* Other) const
{
	return ObjectIndex == Other->Index;
}


// Predefined Function

bool FWeakObjectPtr::operator!=(const class UObject* Other) const
{
	return ObjectIndex != Other->Index;
}


}

)";

    f.close();
}

// 生成 SDK.hpp — 主 include 文件，放在 CppSDK/ 层级
// include 路径指向 SDK/ 子目录
inline void GenerateSdkHpp(
    const std::wstring& cppSdkDir,
    const std::vector<std::string>& packageIncludes)
{
    std::wstring path = cppSdkDir + L"/SDK.hpp";
    std::ofstream f(path);
    if (!f.is_open())
    {
        return;
    }

    f << R"(#pragma once

/*
* SDK generated by Xrd-eXternalrEsolve
* Based on Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Includes the entire SDK. Include files directly for faster compilation!

#include "SDK/Basic.hpp"
)";

    for (auto& inc : packageIncludes)
    {
        f << "#include \"SDK/" << inc << "\"\n";
    }

    f << "\n";
    f.close();
}

// 生成辅助文件（PropertyFixup / NameCollisions / Assertions / Containers）
inline void GenerateAuxiliaryFiles(
    const std::wstring& cppSdkDir,
    const std::map<std::string, std::string>& collisionNsMap,
    const std::vector<detail::StructEntry>& entries)
{
    gen::GeneratePropertyFixup(cppSdkDir);
    gen::GenerateNameCollisions(cppSdkDir, collisionNsMap, entries);
    gen::GenerateAssertionsHeader(cppSdkDir);
    gen::GenerateUtfN(cppSdkDir);
    gen::GenerateUnrealContainers(cppSdkDir);
}

} // namespace detail
} // namespace xrd
