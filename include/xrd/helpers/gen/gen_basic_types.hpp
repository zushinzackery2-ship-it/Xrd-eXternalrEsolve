#pragma once
// Xrd-eXternalrEsolve - SDK 生成：Basic.hpp 第一部分
// 生成 Basic.hpp 的头部、Offsets、InSDKUtils、前置声明、
// StaticClass/GetDefaultObj 宏、FUObjectItem/TUObjectArray/FName 等核心类型

#include "../../core/context.hpp"
#include <fstream>
#include <string>
#include <format>

namespace xrd
{
namespace gen
{

// 写入 Basic.hpp 文件头（#pragma once、注释、include）
inline void WriteBasicHeader(std::ofstream& f)
{
    f << R"(#pragma once

/*
* SDK generated by Xrd-eXternalrEsolve
* Based on Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Basic file containing structs required by the SDK

#define VC_EXTRALEAN
#define WIN32_LEAN_AND_MEAN

#include <string>
#include <functional>
#include <type_traits>

#include "../PropertyFixup.hpp"
#include "../UnrealContainers.hpp"
#include "../Assertions.inl"

namespace SDK
{

using namespace UC;

#include "../NameCollisions.inl"

)";
}

// 写入 Offsets 命名空间（GObjects/AppendString/GNames/GWorld/ProcessEvent/ProcessEventIdx）
inline void WriteOffsetsNamespace(std::ofstream& f)
{
    auto& ctx = Ctx();
    uptr base = ctx.mainModule.base;

    // 计算各偏移的 RVA
    u32 gobjectsRva = ctx.off.GObjects ? static_cast<u32>(ctx.off.GObjects - base) : 0;
    u32 appendRva   = ctx.off.AppendNameToString ? static_cast<u32>(ctx.off.AppendNameToString) : 0;
    u32 gnamesRva   = ctx.off.GNames ? static_cast<u32>(ctx.off.GNames - base) : 0;
    u32 gworldRva   = ctx.off.GWorld ? static_cast<u32>(ctx.off.GWorld - base) : 0;
    u32 peRva       = ctx.off.ProcessEvent_Addr ? static_cast<u32>(ctx.off.ProcessEvent_Addr) : 0;
    i32 peIdx       = ctx.off.ProcessEvent_VTableIndex;

    f << R"(/*
* Disclaimer:
*	- The 'GNames' is only a fallback and null by default, FName::AppendString is used
*	- THe 'GWorld' offset is not used by the SDK, it's just there for "decoration", use the provided 'UWorld::GetWorld()' function instead
*/
namespace Offsets
{
)";
    f << std::format("\tconstexpr int32 GObjects          = 0x{:08X};\n", gobjectsRva);
    f << std::format("\tconstexpr int32 AppendString      = 0x{:08X};\n", appendRva);
    f << std::format("\tconstexpr int32 GNames            = 0x{:08X};\n", gnamesRva);
    f << std::format("\tconstexpr int32 GWorld            = 0x{:08X};\n", gworldRva);
    f << std::format("\tconstexpr int32 ProcessEvent      = 0x{:08X};\n", peRva);
    f << std::format("\tconstexpr int32 ProcessEventIdx   = 0x{:08X};\n", peIdx >= 0 ? peIdx : 0);
    f << "}\n\n";
}

// 写入 InSDKUtils 命名空间
inline void WriteInSDKUtils(std::ofstream& f)
{
    f << R"(namespace InSDKUtils
{
	uintptr_t GetImageBase();

	template<typename FuncType>
	inline FuncType GetVirtualFunction(const void* ObjectInstance, int32 Index)
	{
		void** VTable = *reinterpret_cast<void***>(const_cast<void*>(ObjectInstance));

		return reinterpret_cast<FuncType>(VTable[Index]);
	}

	template<typename FuncType, typename... ParamTypes>
	requires std::invocable<FuncType, ParamTypes...>
	inline auto CallGameFunction(FuncType Function, ParamTypes&&... Args)
	{
		return Function(std::forward<ParamTypes>(Args)...);
	}
}

)";
}

// 写入前置声明和 BasicFilesImpleUtils
inline void WriteForwardDeclarations(std::ofstream& f)
{
    f << R"(
// Forward declarations because in-line forward declarations make the compiler think 'GetStaticClass()' is a class template
class UClass;
class UObject;
class UFunction;

class FName;

namespace BasicFilesImpleUtils
{
	// Helper functions for GetStaticClass and GetStaticBPGeneratedClass
	UClass* FindClassByName(const std::string& Name, bool bByFullName = false);
	UClass* FindClassByFullName(const std::string& Name);

	std::string GetObjectName(class UClass* Class);
	int32 GetObjectIndex(class UClass* Class);

	/* FName represented as a uint64. */
	uint64 GetObjFNameAsUInt64(class UClass* Class);

	UObject* GetObjectByIndex(int32 Index);

	UFunction* FindFunctionByFName(const FName* Name);

	FName StringToName(const wchar_t* Name);
}

const FName& GetStaticName(const wchar_t* Name, FName& StaticName);

)";
}

// 写入 GetStaticClassImpl / GetStaticBPGeneratedClass 模板
inline void WriteStaticClassTemplates(std::ofstream& f)
{
    f << R"(template<bool bIsFullName = false>
class UClass* GetStaticClassImpl(const char* Name, class UClass*& StaticClass)
{
	if (StaticClass == nullptr)
	{
		if constexpr (bIsFullName) {
			StaticClass = BasicFilesImpleUtils::FindClassByFullName(Name);
		}
		else /* default */ {
			StaticClass = BasicFilesImpleUtils::FindClassByName(Name);
		}
	}

	return StaticClass;
}

template<bool bIsFullName = false>
class UClass* GetStaticBPGeneratedClass(const char* Name, int32& ClassIdx, uint64& ClassNameIdx)
{
	/* Could be external function, not really unique to this StaticClass functon */
	static auto SetClassIndex = [](UClass* Class, int32& Index, uint64& ClassName) -> UClass*
		{
			if (Class)
			{
				Index = BasicFilesImpleUtils::GetObjectIndex(Class);
				ClassName = BasicFilesImpleUtils::GetObjFNameAsUInt64(Class);
			}

			return Class;
		};

	/* Use the full name to find an object */
	if constexpr (bIsFullName)
	{
		if (ClassIdx == 0x0) [[unlikely]]
			return SetClassIndex(BasicFilesImpleUtils::FindClassByFullName(Name), ClassIdx, ClassNameIdx);

		UClass* ClassObj = static_cast<UClass*>(BasicFilesImpleUtils::GetObjectByIndex(ClassIdx));

		/* Could use cast flags too to save some string comparisons */
		if (!ClassObj || BasicFilesImpleUtils::GetObjFNameAsUInt64(ClassObj) != ClassNameIdx)
			return SetClassIndex(BasicFilesImpleUtils::FindClassByFullName(Name), ClassIdx, ClassNameIdx);

		return ClassObj;
	}
	else /* Default, use just the name to find an object*/
	{
		if (ClassIdx == 0x0) [[unlikely]]
			return SetClassIndex(BasicFilesImpleUtils::FindClassByName(Name), ClassIdx, ClassNameIdx);

		UClass* ClassObj = static_cast<UClass*>(BasicFilesImpleUtils::GetObjectByIndex(ClassIdx));

		/* Could use cast flags too to save some string comparisons */
		if (!ClassObj || BasicFilesImpleUtils::GetObjFNameAsUInt64(ClassObj) != ClassNameIdx)
			return SetClassIndex(BasicFilesImpleUtils::FindClassByName(Name), ClassIdx, ClassNameIdx);

		return ClassObj;
	}
}

template<class ClassType>
ClassType* GetDefaultObjImpl()
{
	UClass* StaticClass = ClassType::StaticClass();

	if (StaticClass)
	{
		return reinterpret_cast<ClassType*>(StaticClass->DefaultObject);
	}

	return nullptr;
}

)";
}

// 写入 STATIC_CLASS_IMPL / BP_STATIC_CLASS_IMPL / STATIC_NAME_IMPL 宏
inline void WriteStaticClassMacros(std::ofstream& f)
{
    f << R"(#define STATIC_CLASS_IMPL(NameString) \
{ \
    static UClass* Clss = nullptr; \
    return GetStaticClassImpl(NameString, Clss); \
}

#define STATIC_CLASS_IMPL_FULLNAME(FullNameString) \
{ \
    static UClass* Clss = nullptr; \
    return GetStaticClassImpl<true>(FullNameString, Clss); \
}

#define BP_STATIC_CLASS_IMPL(NameString) \
{ \
    static int32 ClassIdx = 0;   \
    static uint64 ClassName = 0; \
    return GetStaticBPGeneratedClass(NameString, ClassIdx, ClassName); \
}

#define BP_STATIC_CLASS_IMPL_FULLNAME(FullNameString) \
{ \
    static int32 ClassIdx = 0;   \
    static uint64 ClassName = 0; \
    return GetStaticBPGeneratedClass<true>(FullNameString, ClassIdx, ClassName); \
}

#define STATIC_NAME_IMPL(NameString) \
{ \
    static FName Name = FName(); \
    return GetStaticName(NameString, Name); \
}

)";
}

} // namespace gen
} // namespace xrd
