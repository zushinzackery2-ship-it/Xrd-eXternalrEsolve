#pragma once
// Xrd-eXternalrEsolve - SDK 生成：UnrealContainers.hpp 和 UtfN.hpp
// 这两个文件是静态内容，直接从 Rei-Dumper 参考复制
// 因为内容太大（各 500+ 行），这里只生成精简版本
// 精简版保留所有必要的类型定义，确保 SDK 可编译

#include "gen_containers_impl.hpp"
#include <fstream>
#include <string>
#include <filesystem>

namespace xrd
{
namespace gen
{

// 生成精简版 UtfN.hpp — 只保留 FString::ToString 需要的最小实现
inline void GenerateUtfN(const std::wstring& cppSdkDir)
{
    std::wstring path = cppSdkDir + L"/UtfN.hpp";
    std::ofstream f(path);
    if (!f.is_open()) return;

    f << R"(#pragma once

/*
* SDK generated by Xrd-eXternalrEsolve
* Based on Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// A simple C++ lib for converting between Utf8, Utf16 and Utf32. See https://github.com/Fischsalat/UTF-N
// Simplified version - only Utf16 to Utf8 conversion needed for FString::ToString

#include <string>
#include <cstdint>

namespace UtfN
{

// 将 UTF-16 字符串转换为 UTF-8
template<typename StringType = std::string>
inline StringType Utf16StringToUtf8String(const wchar_t* Str, int32_t Length)
{
    StringType Result;
    Result.reserve(Length);

    for (int32_t i = 0; i < Length; ++i)
    {
        wchar_t Ch = Str[i];

        if (Ch == 0)
            break;

        if (Ch < 0x80)
        {
            Result += static_cast<char>(Ch);
        }
        else if (Ch < 0x800)
        {
            Result += static_cast<char>(0xC0 | (Ch >> 6));
            Result += static_cast<char>(0x80 | (Ch & 0x3F));
        }
        else
        {
            // 处理代理对
            if (Ch >= 0xD800 && Ch <= 0xDBFF && (i + 1) < Length)
            {
                wchar_t Lo = Str[i + 1];
                if (Lo >= 0xDC00 && Lo <= 0xDFFF)
                {
                    uint32_t Cp = 0x10000 + ((Ch - 0xD800) << 10) + (Lo - 0xDC00);
                    Result += static_cast<char>(0xF0 | (Cp >> 18));
                    Result += static_cast<char>(0x80 | ((Cp >> 12) & 0x3F));
                    Result += static_cast<char>(0x80 | ((Cp >> 6) & 0x3F));
                    Result += static_cast<char>(0x80 | (Cp & 0x3F));
                    ++i;
                    continue;
                }
            }
            Result += static_cast<char>(0xE0 | (Ch >> 12));
            Result += static_cast<char>(0x80 | ((Ch >> 6) & 0x3F));
            Result += static_cast<char>(0x80 | (Ch & 0x3F));
        }
    }

    return Result;
}

template<typename StringType = std::string>
inline std::wstring StringToWString(const StringType& Str)
{
    std::wstring Result;
    Result.reserve(Str.size());

    for (auto Ch : Str)
    {
        Result += static_cast<wchar_t>(static_cast<unsigned char>(Ch));
    }

    return Result;
}

}

)";
    f.close();
}

// 生成 UnrealContainers.hpp — 包含 TArray / FString / TSet / TMap 等容器
// 这是 SDK 运行时必需的，直接嵌入完整实现
inline void GenerateUnrealContainers(const std::wstring& cppSdkDir)
{
    std::wstring path = cppSdkDir + L"/UnrealContainers.hpp";
    std::ofstream f(path);
    if (!f.is_open()) return;

    f << R"(#pragma once

/*
* SDK generated by Xrd-eXternalrEsolve
* Based on Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Container implementations with iterators. See https://github.com/Fischsalat/UnrealContainers

#include <string>
#include <stdexcept>
#include <iostream>
#include "UtfN.hpp"

namespace UC
{	
	typedef int8_t  int8;
	typedef int16_t int16;
	typedef int32_t int32;
	typedef int64_t int64;

	typedef uint8_t  uint8;
	typedef uint16_t uint16;
	typedef uint32_t uint32;
	typedef uint64_t uint64;

	template<typename ArrayElementType>
	class TArray;

	template<typename SparseArrayElementType>
	class TSparseArray;

	template<typename SetElementType>
	class TSet;

	template<typename KeyElementType, typename ValueElementType>
	class TMap;

	template<typename KeyElementType, typename ValueElementType>
	class TPair;

)";
    f.close();

    // 追加容器实现的核心部分
    std::ofstream fa(path, std::ios::app);
    WriteContainerImpl(fa);
    fa.close();
}

} // namespace gen
} // namespace xrd
